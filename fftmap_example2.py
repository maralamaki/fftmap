"""
fftmap_example2.py - example of fftmap library use

This program demonstrates the use of fftmap library.

It is shown here how spots can be added to a map in such a way that exactly the
desired percentage of the map is covered by the spots. It is also shown how the
average size of the spots can be varied using different cutoff frequencies.
    
--------------------------------------------------------------------------------
LICENCE - MIT Licence

Copyright (c) 2020 Markku Alam√§ki

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
"""

import fftmap
import math
import random
import PIL.Image
import numpy as np
import scipy.stats

# Map size
SIZE = 10000
RANGES = [[-SIZE, SIZE], [-SIZE, SIZE]]

# Function for generating a spctral filter with a cutoff wavelength
def get_spectral_filter(wave_cutoff):
    # Small number to avoid divide by zero error
    epsilon = 0.000000001
    # Spectral filter
    #     - (1/k)^2 factor prevents the high frequencies from dominating too much
    #     - A short pass step filter removes longest wavelengths
    return lambda k: int((1 / (k + epsilon)) < wave_cutoff) * 1 / (k + epsilon) ** 2

# Function for creating maps with specified spatial frequency cutoff
def create_map(wave_cutoff, seed=None):
    # Use large enough block size to support maximum wavelength
    block_size = int(wave_cutoff)

    #
    spectral_filter = get_spectral_filter(wave_cutoff)

    # We select the numpy's ndarray since it gives less overhead with the
    # FFTMap.get_value method.
    array_type = "ndarray"

    # Create the map and return it
    return fftmap.FFTMap(RANGES, block_size, spectral_filter, seed=seed, array_type=array_type)

# To demonstrate the probability distribution generated by FFTMap, we generate
# a map where: 5% of the map is painted red, 5% green, and 10% blue. To this end,
# we define the following variables:
red_probability = 0.05
green_probability = 0.05
blue_probability = 0.10

# We also say that we want the colors to appear in differntly sized spots:
red_spot_scale = 10
green_spot_scale = 50
blue_spot_scale = 250

# We create maps with the wavelength cutoffs defined as the spot sizes:
red_map = create_map(red_spot_scale, seed=0)
green_map = create_map(green_spot_scale, seed=1)
blue_map = create_map(blue_spot_scale, seed=2)

# We then define a color function that takes as argument the values returned by
# the maps and returns the color.
# Since the output of the maps forms a Gaussian distribution, we can
# select a slice from the probability distribution function that integrates
# to the probability we want. One possible way is to use the inverse of the
# cumulative distribution function (CDF) like so:
red_ppf = scipy.stats.norm.ppf(red_probability)
green_ppf = scipy.stats.norm.ppf(green_probability)
blue_ppf = scipy.stats.norm.ppf(blue_probability)
def color_fun(red_map_value, green_map_value, blue_map_value):
    return (
        int(red_map_value < red_ppf) * 255,
        int(green_map_value < green_ppf) * 255,
        int(blue_map_value < blue_ppf) * 255
    )

# Image size, we don't render the entire map we have defined, but only small
# portion of it.
IMAGE_SIZE_X = 500
IMAGE_SIZE_Y = 500

# Fetch data from the map in the size of the image
red_channel = red_map.get_values(0, IMAGE_SIZE_X, 0, IMAGE_SIZE_Y)
green_channel = green_map.get_values(0, IMAGE_SIZE_X, 0, IMAGE_SIZE_Y)
blue_channel = blue_map.get_values(0, IMAGE_SIZE_X, 0, IMAGE_SIZE_Y)

# Create and save the image
rgb_data = np.zeros([IMAGE_SIZE_X, IMAGE_SIZE_Y, 3], dtype=np.int8)
for i in range(IMAGE_SIZE_X):
    for j in range(IMAGE_SIZE_Y):
        rgb_data[i, j] = color_fun(
            red_channel[i, j],
            green_channel[i, j],
            blue_channel[i, j]
        )
image = PIL.Image.fromarray(rgb_data, "RGB")
image.save("fftmap_example2_out.png")


